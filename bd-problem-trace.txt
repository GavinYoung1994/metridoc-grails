In BdEzbController.groovy
	In summary() function:
		variable data is defined as borrowDirectService.getSummaryDashboardData(libId, fiscalYear, serviceKey, selectedLibIds)
		where libId = params.library != null? params.long("library"):null,
		fiscalYear = params.fiscalYear != null ? params.int('fiscalYear'):null,
		serviceKey = BorrowDirectService.BD_SERVICE_KEY (public static String BD_SERVICE_KEY = 'bd'),
		and selectedLibIds = getSelectedLibs(params.list('lIds'));
	question: what is "params"?


Then in BorrowDirectService.groovy
	function getSummaryDashboardData is called and in this function, loadDataPerLibrary function is called twice, with the following parameters:
	{
		sql = getSql()
		true/false
		result = [:], result,currentMonth = Calendar.getInstance().get(Calendar.MONTH), result.fiscalYear = DateUtil.getFiscalYear(currentYear,currentMonth)
		dates = [:], dates.currentFiscalYear = [currentFiscalYearStart,currentFiscalYearEnd], dates.lastFiscalYear = [DateUtil.getFiscalYearStartDate(currentFiscalYear - 1), lastFiscalYearEnd]
		libId = libId from parent function
		serviceKey = serviceKey from parent function
	}

	Then in lodaDataPerLibrary function, setFillRate is called three times in three different if scenarios:
		if there is no LibId, and either notEZborrow or isBorrowing, 
			allQuery = isBorrowing ? config.queries.borrowdirect.countsAllPerBorrower : config.queries.borrowdirect.countsAllPerLender;
			allQuery = getAdjustedQuery(allQuery, "", additionalCondition, tablePrefix)
				where addtionalCondition = "and " + config.borrowdirect.db.column.borrower + "=" + libId
			then setFillRate is called in the following fashion:
				sql.eachRow(allQuery,
                        sqlParams, {
                    setFillRate(it.getAt(0), it.requestsNum, keyForSection, result)
                })
        if there is a LibId, and notEZBorrow,
        	 allQuery = isBorrowing ? config.queries.borrowdirect.countsAllPerLenderToLib : config.queries.borrowdirect.countsAllPerBorrowerFromLib;
        	 allQuery = prepareQuery(allQuery, tablePrefix)
        	 then setFillRate is called in the following fashion:
        	 	sql.eachRow(allQuery,
                        sqlParams, {
                    setFillRate(it.getAt(0), it.requestsNum, keyForSection, result)
                })
        if there is a LibId, and either notEZBorrow or isBorrowing,
        	allQuery = isBorrowing ? config.queries.borrowdirect.countsAllBorrowedByLib : config.queries.borrowdirect.countsAllTouchedByLib;
        	allQuery = prepareQuery(allQuery, tablePrefix)
        	then setFileRate is called in the following fashion:
        		setFillRate(-1, row != null ? row.requestsNum : 0, keyForSection, result)
    if isBorrowing is true, the keyForSection is 'borrowing', otherwise it is 'lending'
    tablePrefix is the serviceKey from the parent function


In the Queries.groovy, we can find the 6 actual SQL queries needed for calculating fill rates:


/**
		* for fillRate in Borrowing
		*/
		countsAllPerBorrower = '''
		   select IFNULL(borrower,-1) as borrower, count(distinct request_number) as requestsNum 
		   from {table_prefix}_bibliography 
		   where request_date between ? and ? 
		   and NOT (borrower <=> lender) {add_condition} 
		   group by borrower WITH ROLLUP
		'''

		/**
		* for fillRate in Leniding, rollup here, does not double count
		* in case of selected sublibs 'All Libraries' row is not the same as for borrowing
		*/
		countsAllPerLender = '''
		   select IFNULL(pd.library_id,-1) as lender, count(distinct bl.request_number) as requestsNum 
		   from {table_prefix}_bibliography bl
		   inner join {table_prefix}_print_date pd on bl.request_number = pd.request_number
		   where request_date between ? and ? 
		   and borrower != pd.library_id {add_condition} 
		   group by pd.library_id WITH ROLLUP
		'''

		/**
		* Fill rate in borrowing section for lib to lib
		*/
		//missing 10000009 and 10000014
		// SELECT count(request_date),lender from bd_bibliography where lender = '10000009' and request_date between '2016-07-01 00:00:00' and '2017-04-12 00:00:00' group by lender
		// SELECT count(print_date),library_id from bd_print_date where library_id = '10000009' and print_date between '2015-07-01 00:00:00' and '2017-04-12 00:00:00' group by library_id
		//10000012 is missing from the institution table
			/**
		* Fill rate in lending section for lib to lib
		*/
		//old version
		countsAllPerBorrowerFromLib = '''
		   select borrower, count(distinct bl.request_number) as requestsNum 
		   from {table_prefix}_bibliography bl left join {table_prefix}_print_date pd on bl.request_number = pd.request_number
		   where request_date between ? and ? 
		   and pd.library_id = ? 
		   and borrower != pd.library_id 
		   and NOT (borrower <=> lender) 
		   group by borrower
		'''
		// countsAllPerBorrowerFromLib = '''
		//    select borrower, count(distinct request_number) as requestsNum 
		//    from {table_prefix}_bibliography
		//    where request_date between ? and ? 
		//    and ((lender is null and pd.library_id = ?) or lender = ?)
		//    and NOT (borrower <=> lender) 
		//    group by borrower
		// '''

		/**
		* Fill rate in borrowing section for lib to lib
		*/
		//old version
		// countsAllPerLenderToLib = '''
		// 	select pd.library_id as lender, count(distinct bl.request_number) as requestsNum 
		// 	from {table_prefix}_bibliography bl inner join {table_prefix}_print_date pd on bl.request_number = pd.request_number
		// 	where request_date between ? and ? 
		// 	and borrower = ? 
		// 	and borrower != pd.library_id 
		// 	and NOT (borrower <=> lender) 
		// 	group by pd.library_id
		// '''
		countsAllPerLenderToLib = '''
			select lender, count(distinct request_number) as requestsNum 
			from {table_prefix}_bibliography
			where request_date between ? and ? 
			and borrower = ? 
			and NOT (borrower <=> lender) 
			group by lender
		'''

		/**
		* for fill rate in All Libraries row -Borrowing
		*/
		countsAllBorrowedByLib = '''
			select count(distinct request_number) as requestsNum 
			from {table_prefix}_bibliography where
			request_date between ? and ? 
			and borrower = ? 
			and NOT (borrower <=> lender)
		'''

	   /**
		* for fill rate in All Libraries row  - Lending
		*/
		countsAllTouchedByLib = '''
			select count(distinct bl.request_number) as requestsNum 
			from {table_prefix}_bibliography bl inner join {table_prefix}_print_date pd on bl.request_number = pd.request_number
			where request_date between ? and ? 
			and pd.library_id = ? 
			and NOT (borrower <=> lender)
		'''
	   
And this is the setFillRate function:
	private static setFillRate(libId, requestsNum, keyForSection, result) {
        def libData = getLibDataMap(libId, result)
        def currentMap = libData.get(keyForSection)
        if (currentMap.currentFiscalYear.get(-1) == null) {
            currentMap.currentFiscalYear.put(-1, 0);
        }
        currentMap.yearFillRate = (requestsNum != 0 ?
                currentMap.currentFiscalYear.get(-1) / (float) requestsNum : -1)
    }

    private static getLibDataMap(libId, container) {
        libId = libId.longValue()
        if (container.get(libId) == null) {
            container.put(libId, ['borrowing': ['currentFiscalYear': [:], 'lastFiscalYear': [:]],
                    'lending': ['currentFiscalYear': [:], 'lastFiscalYear': [:]]])
        }
        return container.get(libId)
    }




    Invalid fillrate:
    	(Seems everyone is having problem with Columbia and Duke)
    	Brown University : 2016 and 2017 borrowing
    	Columbia University: 2016 and 2017 both lending and borrowing, *every entry in 2017 lending is Invalid
    	Cornell University: 2016 and 2017 borrowing
    	Dartmouth College: 2016 and 2017 borrowing
    	Duke University: 2015, 2016 and 2017 borrowing and lending *The only data Duke has is the borrowing data of 2015 and both borrowing and lending of 2016 and 2017
    																every entry of the lending table is Invalid
 		John Hopkins: 2016 and 2017 borrowing *no fill rate for lending at all
 		Harvard: 2016 and 2017 borrowing
 		MIT: 2016 and 2017 borrowing
 		Penn: 2017 borrowing and lending, 2016 borrowing
 		Princeton: 2016 and 2017 borrowing and lending
 		UChicago: 2016 and 2017 borrowing
 		Yale: 2015 lending, 2016 and 2017 lending and borrowing *every entry in 2016 and 2017 lending is invalid except one